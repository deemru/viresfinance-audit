# Vires.Finance аудит безопасности

- [Vires.Finance аудит безопасности](#viresfinance-аудит-безопасности)
  - [Область исследования](#область-исследования)
  - [Состав проекта](#состав-проекта)
  - [Безопасность](#безопасность)
    - [Общее](#общее)
    - [Администрирование](#администрирование)
  - [Архитектура](#архитектура)
    - [RESERVE](#reserve)
    - [MAIN](#main)
    - [SETTINGS](#settings)
  - [Модель угроз](#модель-угроз)
    - [Атаки на аргументы](#атаки-на-аргументы)
    - [Атаки амплификации](#атаки-амплификации)
  - [Прочие рекомендации](#прочие-рекомендации)
  - [Выводы](#выводы)

## Область исследования

Исследуется проект Vires.Finance по состоянию до 8 ноября 2021 года включительно.

Объектом исследования является безопасность работы проекта в основной сети Waves.

На момент исследования, проект представляет собой экосистему состоящую из 13 смарт-контрактов и аккаунта администратора. Внешней зависимостью данной экосистемы является функционал ценовых оракулов и стейкинга токенов WAVES, USDN и EURN.

Так как функционалы ценовых оракулов и стейкинга USDN и EURN являются зоной ответственности [протокола Neutrino](https://neutrino.at), а распределение стейкинга WAVES лежит в зоне ответственности владельцев нод, данные подсистемы не являются объектом полноценного аудита.

## Состав проекта

Состав проекта определяется по открытой информации представленной на официальном сайте [Vires.Finance](https://vires.finance) и дополнительной информации от команды разработчиков, включающей актуальные исходные коды смарт-контрактов и адреса их установки в основной сети Waves.

Итоговый набор контрактов:

```php
$main = [
    ['main',            '3PAZv9tgK1PX7dKR7b4kchq5qdpUS3G5sYT'],
    ['settings',        '3PJ1kc4EAPL6fxuz3UZL68LPz1G9u4ptjYT'],
    ['oracle-proxy',    '3PFHm5TYKw4vVzj4rW8s3Yso88aD73Dai1C'],
];

$stakers = [
    ['staker-waves',    '3PMHsJn1G4ngd6A4dyZpaSMiQmr4XJiDuym'],
    ['staker-usdn',     '3P23drfMhqqouvzpt3xUyGwjVX8P8qAzrmi'],
    ['staker-eurn',     '3PH9oV2vraW7z7BxbMjHjcCMg3dmBKmUyhh'],
];

$reserves = [
    ['reserve',         '3P8G747fnB1DTQ4d5uD114vjAaeezCW4FaM'], // WAVES
    ['reserve',         '3PCwFXSq8vj8iKitA5zrrLRbuqehfmimpce'], // USDN
    ['reserve',         '3PEiD1zJWTMZNWSCyzhvBw9pxxAWeEwaghR'], // USDT
    ['reserve',         '3PGCkrHBxFMi7tz1xqnxgBpeNvn5E4M4g8S'], // USDC
    ['reserve',         '3PBjqiMwwag72VWUtHNnVrxTBrNK8D7bVcN'], // EURN
    ['reserve',         '3PA7QMFyHMtHeP66SUQnwCgwKQHKpCyXWwd'], // BTC
    ['reserve',         '3PPdeWwrzaxqgr6BuReoF3sWfxW8SYv743D'], // ETH
];

$vires = [
    ['vires-earlybirds',    '3PMqStMdARUA1KDNSrknUkQgXBVJR9Kgxko'],
    ['vires-minter',        '3PM9SV8qsubjwfxENgsLJvP1BG2Wc2VAd7b'],
    ['vires-staker',        '3PMrcFXJx23B9zbxxUT49z6ET6wF2dKfTdW'],
    ['vires-distributor',   '3P2RkFDTHJCB82HcVvJNU2eMEfUo82ZFagV'],
];

```

Систематизация смарт-контрактов происходит в автоматическом режиме с помощью скрипта [test-contracts](https://github.com/deemru/viresfinance-audit/blob/main/test/test-contracts.php). Данный скрипт находит последнюю транзакцию установки смарт-контракта, декомпилирует смарт-контракт средствами ноды Waves и записывает данную информацию в файл. Имя файла содержит префикс, который является контрольной суммой кода декомпилированного контракта.

По полученным данным смарт-контракты можно представить как:

- MAIN (основной узловой контракт)
- SETTINGS (центральные настройки)
- ORACLE (поставщик цен)
- 3 STAKER (стейкинг WAVES, USDN и EURN с общим интерфейсом)
- 7 RESERVE (учёт депозитов, долгов и резерва по токену с общим интерфейсом)
- VIRES-MINTER (выпуск VIRES)
- VIRES-EARLYBIRDS (распределение VIRES для ранних инвесторов)
- VIRES-DISTRIBUTOR (распределение VIRES за депозит и долг)
- VIRES-STAKER (распределение VIRES за стейкинг VIRES)

## Безопасность

### Общее

Рассматриваются смарт-контракты Vires.Finance с точки зрения сохранности пользовательских средств в общем виде, безотносительно функционала внутреннего перерасчёта.

Ведение балансов происходит в [хранилищах данных аккаунтов](https://docs.waves.tech/en/blockchain/account/account-data-storage) смарт-контрактов типа RESERVE, у каждого смарт-контракта своё непересекающееся с другими хранилище, оно может быть представлено как база данных пар ключ/значение. При этом ключи пользовательского учёта помимо смысловых префиксов и постфиксов всегда содержат адреса пользователей, что равносильно типичному хранению токенов в блокчейне, где ключ в базе данных блокчейна можно представить как адрес пользователя плюс идентификатор токена. При этом значением в обоих случаях будет баланс токенов.

Идентификатор токенов однозначно определяется адресом RESERVE и не меняется в процессе работы.

Адрес пользователя определяется по адресу отправителя пользовательской транзакции, что гарантирует прохождение [всех проверок, связанных с аккаунтом пользователя](https://docs.waves.tech/en/ride/functions/verifier-function) (например, дополнительных к проверке подписи по умолчанию действий, в соответствии со смарт-аккаунтом пользователя, при наличии).

В контрактах присутствует функциональность, которая может уменьшать значения депозитов пользователей. Данное отрицательное влияния на учётные записи возникает только в случае превышения долга пользователя согласно формуле над его общим депозитом (функции `transferDebt()` и `forceCollapse()`), при отсутствии долга или отсутствии превышения долга согласно формуле над депозитом отрицательные влияния полностью отсутствуют, за исключением действий самого пользователя, например при выводе средств.

В контрактах отсутствует функциональность смены владельца записи, что однозначно фиксирует управление пользовательскими средствами самим пользователем. Поэтому наиболее близким аналогом ведения учёта в контрактах Vires.Finance является нативная работа лизинга, транзакций [Lease](https://docs.waves.tech/en/blockchain/transaction-type/lease-transaction) и [Lease Cancel](https://docs.waves.tech/en/blockchain/transaction-type/lease-cancel-transaction) в основной сети Waves.

### Администрирование

Автоматизированный анализ контрактов на наличие фиксированных строк со значениями предопределённых ключей и адресов проводится скриптом [test-strings](https://github.com/deemru/viresfinance-audit/blob/main/test/test-strings.php). Данный скрипт находит последнюю транзакцию установки смарт-контракта, декомпилирует смарт-контракт средствами ноды Waves и находит все используемые записи переменных, соответствующие открытым ключам и выводит сводную информацию на экран.

Автоматизированный анализ хранилищ данных контрактов на наличие ключей с определёнными подстроками проводится скриптом [test-data](https://github.com/deemru/viresfinance-audit/blob/main/test/test-data.php).

Анализ фиксированных в контрактах строк показывает отсутствие предопределённых открытых ключей или адресов управления. Все настройки контрактов задаются транзакциями инициализации в функциях `initialize()` и `init()`, в которых определяется контракт с общими настройками SETTINGS и адрес администратора.

Во всех контрактах используется единый адрес администратора ADMIN.

Во всех контрактах, кроме ORACLE и STAKER, используется единый адрес общих настроек SETTINGS.

Наблюдается неконсистентность в логике определения администратора и отсутствие установки общих настроек для некоторых вспомогательных контрактов, в большинстве контрактов администратор фиксируется непосредственно в собственных хранилищах, однако для RESERVE контрактов и VIRES-EARLYBIRDS администратор определяется через контракт SETTINGS.

РЕКОМЕНДУЕТСЯ унифицировать логику работы по определению администратора только через контракт общих настроек SETTINGS, что упростит логику инициализации и администрирования проекта в целом.

Во всех контрактах и на адресе администратора отсутствует переопределение [функции Verifier](https://docs.waves.tech/en/ride/functions/verifier-function), что означает сохранение штатного функционала проверки транзакций в основной сети Waves. Таким образом, исходящие транзакции от имени контракта и администратора будут проверены на исходных ключах соответствующих им адресов.

РЕКОМЕНДУЕТСЯ улучшить [систему управления ключами](https://en.wikipedia.org/wiki/Key_management), например в рамках унификации логики работы SETTINGS, а также ввести схему [мультиподписи](https://en.wikipedia.org/wiki/Multisignature) для всех контрактов.

На текущий момент все адреса контрактов были использованы только для установки и обновления целевых контрактов. Исключением является одна [транзакция данных](https://docs.waves.tech/en/blockchain/transaction-type/data-transaction) установки ключа `op_transfer_debt_paused` в значение `true`. От команды разработчиков получена информация, что они знают о возможности установки данного флага штатным функционалом администрирования в функции `resume()` в контракте SETTINGS, однако в данном случае был использован наиболее оперативный метод для проведения обслуживания контракта во время аудита.

На текущий момент не обнаружено централизованное место с регистрацией действий администраторов с описанием причин данных действий. Несмотря на то, что все действия в блокчейне Waves являются открытыми и проверяемыми, РЕКОМЕНДУЕТСЯ вести публичный учёт административных действий, а также рассмотреть возможность разрешения действий администратора через механизмы [DAO](https://en.wikipedia.org/wiki/Decentralized_autonomous_organization).

## Архитектура

Рассматриваются смарт-контракты Vires.Finance с точки зрения архитектурных особенностей направленных на нивелирование уязвимостей при вызове доступных функций.

### RESERVE

Непосредственное хранение пользовательских токенов сосредоточено в RESERVE контрактах. При наличии возможности стейкинга в RESERVE контракте, пользовательские токены в полном объёме через STAKER контракты атомарно отправляются в соответствующие системы стейкинга. STAKER контракты однозначно привязываются к соответствующим RESERVE при инициализации и не содержат функций доступных пользователям отличных от RESERVE и ADMIN. Возможность снятия средств в полном объёме в случае необходимости гарантируется штатным функционалом основной сети Waves в случае WAVES токенов и протоколом Neutrino в случае USDN и EURN.

Так как в RESERVE контактах невозможно возникновение отрицательных значений при штатной работе, при записи значений в хранилище всегда используется функция `writeInt()`, которая выдаёт ошибку при возникновении любого отрицательного значения. Данная особенность является простым решением гарантирующим не выход за штатный функционал работы, а также отсекающим и тем самым облегчающим анализ всех отрицательных вариантов использования.

При каждом изменении депозита, долга и резерва в RESERVE контрактах происходит синхронизация текущего учёта в функции `syncTotals()`. Такой подход позволяет сосредоточить основной функционал в общем месте, что гарантирует единообразность исполнения всех вариантов увеличения и уменьшения значений депозита, долга и резерва.

Для работы функционального роста значений в соответствие с протоколом и настройками в SETTINGS в контракте RESERVE используется индекс. Индекс может увеличиваться 1 раз за блок, так как является производным от настроек и разницы текущей высоты блока основной сети Waves и высоты прошлого вызова. Такой подход гарантирует поступательный с шагом в 1 блок рост депозита, долга и резерва, что исключает возможность получения или потери каких-либо средств, если их участие в работе системы заняло менее 1 блока.

### MAIN

RESERVE контракты исполняются через MAIN контракт, так как сами не обладают полнотой информации о пользователе и учётом дистрибуции токенов VIRES.

MAIN контракт не обладает и не ведёт учёт пользовательских средств, являясь при этом центральным местом, которое сводит общую информацию о пользователе в системе Vires.Finance, что позволяет принимать решение о возможностях пользователей в системе и разрешать или запрещать выполнение определённых действий.

Контроль за всеми действиями, которые могут оказать отрицательное влияния на систему сосредоточен в функции `validateAfter()`, которая проводит финальный аудит пользователя по всем RESERVE в соответствие с SETTINGS. Такой подход позволяет упростить логику исполнения, которая в данном случае не требует дополнительных предварительных проверок пользовательского сценария, так как `validateAfter()`, после применения всех действий в рамках транзакции в других контрактах, гарантирует, что итоговое состояние пользователя находится в рамках протокола, в противном случае возвращает ошибку на всю транзакцию.

### SETTINGS

Как уже было отмечено ранее, все основные контракты подключены и зависят от централизованного контракта с настройками SETTINGS.

SETTINGS не только предоставляет ключевые настройки протокола, но также является поставщиком разрешений для работы определённых сценариев, вплоть до точечного запрещения определённых функций в зависимых контрактах. Для этого используется система 3 уровней: 1) глобальная пауза проекта 2) пауза определённой функции 3) пауза определённой функции для определённого токена.

Таким образом, новый, устаревший или проблемный функционал может быть отключен, не влияя на работу протокола в целом. Например, на текущий момент без ущерба для работы протокола отключен функционал по работе с `atokens`.

Замечено, что названия ключей, которые разрешают/отключают определённый функционал, содержат окончание `_paused`, при этом значение такого ключа `true` является разрешающим действие. НЕ РЕКОМЕНДУЕТСЯ использовать противоположный смысл названия ключей и их смысла.

## Модель угроз

Рассматриваются смарт-контракты Vires.Finance с точки зрения наличия уязвимостей. Под уязвимостями понимаются любые действия в рамках работы контрактов в основной сети Waves, которые могут негативно повлиять работу протокола Vires.Finance. Под негативным влиянием, кроме непосредственной потере средств, также понимается внесение любых искажений в штатные расчёты и формулы.

Так как проявление угроз возможно только с помощью транзакций, рассматриваются возможности типичного пользователя системы. Угрозы компрометации закрытых ключей смарт-контрактов и угрозы связанные с действиями администратора не рассматриваются в силу текущего состояния [администрирования](#администрирование).

Транзакции типичного пользователя системы в основной сети Waves могут повлиять на работу текущих контрактов только при изменении их состояния, что достигается наличием действий в результатах выполнения контракта. Как правило это действия записи нового значения по ключу и трансфер токена по адресу. Таким образом, в анализе на угрозы сначала локализуются функции, которые содержат целевые итоговые действия, и функции, которые вызывают эти функции.

Также первичный анализ предполагает определение всех функций в системе доступных типичному пользователю, которые хотя бы теории могут пересекаться с локализованным набором функций с итоговыми действиями.

Данный анализ показывает, что функционал Vires.Finance доступный типичному пользователю не выходит за рамки заявленного протоколом функционала. Все сервисные функции, предполагающие взаимодействие контрактов между собой, имеют проверку вызывающего о принадлежности системе и соответствуют заявленной логике. Поэтому набор функций для непосредственного анализа существенно сокращается на данном этапе.

### Атаки на аргументы

Проведено исследование целевого набора функций на предмет искажения смысла аргументов, включая использование:
 - строк с нештатными адресами;
 - строк с нештатными идентификаторами токенов;
 - усеченных/увеличенных строк для попадания в ключи отличные от штатных;
 - отрицательных целочисленных значений;
 - целочисленных значений близких к целочисленному переполнению;
 - целочисленных значений на границах округлений в формулах.

Выявлено, что [архитектурные особенности](#архитектура) защищают от большинства атак на целые числа. Проблем в работе с большими числами и с числами на границах округлений в формулах также не обнаружено.

Выявлено, что атаки на строки с нештатными адресами и идентификаторами токенов обрабатываются соответствующими проверочными функциями (`validateReserve()` и `findReserveBy()`), проблем не обнаружено.

Замечено, что функция `pauseAssetOp()`, которая хоть и не является публичной, имеет возможность записать значение `true` по нештатному ключу. РЕКОМЕНДУЕТСЯ ввести проверку аргумента `assetId` по аналогии с публичными функциями, так как доступ к данной функции может быть расширен группе так называемых пауз-администраторов.

Замечено, что в контракте VIRES-MINTER, несмотря на ограничения вызывающего (`distributorOnly()` и `stakerOnly()`), функции выпуска токенов VIRES содержат непроверяемые значения `recipient`, хотя по логике работы, выпуск токенов VIRES в этих случаях всегда происходит в адрес вызывающего.

РЕКОМЕНДУЕТСЯ максимально ограничивать существующие сценарии в соответствии с логикой работы, так как подобная вариабельность требует дополнительного анализа для подтверждения корректности и дополнительной ответственности от разработчиков сторонних контрактов. В данном случае неочевидны цели подобного обременения.

### Атаки амплификации

Проведено исследование целевого набора функций на предмет увеличения/уменьшения штатных значений при использовании:
- комплексного атомарного вызова состоящего из нескольких вызовов контрактов Vires.Finance
- комплексных вызовов исполненных в рамках одного блока

Выявлено, что [архитектурные особенности](#архитектура) защищают от всех видов подобных атак на депозит, долг, распределение и стейкинг VIRES.

Найдено одно исключение, публичная функция `realloc()` в контракте VIRES-DISTRIBUTOR, которая позволяет выполнять перерасчёт относительной скорости распределения токенов VIRES в зависимости от текущих значений долга в контрактах RESERVE.

Так как данная функция не ограничена в частоте вызовов, пользователь может пересчитать скорость в любой момент, включая искусственно созданный момент перекоса долга в рамках атомарного вызова или одного блока. В итоге, не теряя средств появляется возможность искусственного влияния на относительную скорость распределения токенов VIRES.

Данная атака классифицируется как амплификация, однако она не влияет на суммарное количество распределяемых токенов в день и не гарантирует, что другой пользователь не выполнит перерасчёт сразу после проведения атаки.

Команда в курсе наличия проблемы и будет решать её в следующих версиях протокола с помощью включения данного функционала в общий сценарий атомарного исполнения или изменении прав на публичный вызов данной функции.

## Прочие рекомендации

Функцию `redeemAtokens()` в контрактах RESERVE (в настоящее время функционал `atokens` отключен в SETTINGS) РЕКОМЕНДУЕТСЯ привести к общему виду, по аналогии с другими `atokens` функциями, а именно, вызов только через контракт MAIN, который проведёт соответствующую коррекцию депозита `streamChange` в функции `updateStream()`.

## Выводы

Реализация контрактов Vires.Finance является хорошим примером фундаментального подхода по разделению общего комплексного функционала на отдельные смысловые части, что благодаря рассмотренным [архитектурным особенностям](#архитектура) позволяет с большой вероятностью гарантировать отсутствие уязвимостей и их появление в будущем.

Основной функционал проекта полностью децентрализован и не требует обслуживания на продолжительном промежутке времени.

На рекомендации по текущему состоянию [администрирования](#администрирование) от команды получен ответ о готовящихся улучшениях.

Прочие ошибки найденные в рамках аудита были оперативно исправлены или нивелированы.

На остальные некритичные моменты даны рекомендации в рамках аудита, которые не являются обязательными к исполнению, но должны быть приняты во внимание и тщательно взвешены, прежде чем будет принято решение не учитывать их в следующих версиях проекта.
